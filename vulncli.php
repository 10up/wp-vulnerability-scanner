<?php
/**
 * Plugin Name: WP Vulnerability Scanner
 * Plugin URI:
 * Description: WP-CLI command only.
 *              Check installed plugins and themes for vulnerabilities reported by wpvulndb.com.
 * Version: 0.0.1
 * Author:
 * Author URI:
 * License:
 */

if ( !defined( 'WP_CLI' ) ) return;

/**
 * WP Vulnerability Scanner
 */
class Vulnerability_CLI extends WP_CLI_Command {

	/**
	 * Check plugins and themes for reported vulnerabilities.
	 *
	 * ## OPTIONS
	 *
	 * [--fix]
	 * : Update vulnerable plugins if possible.
	 *
	 * [--not-plugins]
	 * : Do not include plugins in scan. Not to be confused with --skip-plugins.
	 *
	 * [--not-themes]
	 * : Do not include themes in scan. Not to be confused with --skip-themes.
	 *
	 * [--verbose]
	 * : Human-friendly formatting.
	 *
	 * [--test]
	 * : Load test plugin/theme data
	 *
	 * [--format=<format>]
	 * : Accepted values: table, csv, json, count, ids, yaml. Default: table
	 *
	 * ## EXAMPLES
	 *
	 *     wp vuln status
	 *     wp vuln status --fix
	 *
	 * @subcommand status
	 */
	function status( $args, $assoc_args ) {

		$this->fix       = isset( $assoc_args['fix'] );
		$this->verbose   = isset( $assoc_args['verbose'] );
		$this->test      = isset( $assoc_args['test'] );
		$this->doplugins = !isset( $assoc_args['not-plugins'] );
		$this->dothemes  = !isset( $assoc_args['not-themes'] );

		$this->update_list = [];

		if ( $this->doplugins ) {
			// need a copy because it's passed by ref and destroyed in the formatter
			$this->assoc_args_plugin = $assoc_args;
			$this->_do_plugins();
		}

		if ( $this->dothemes ) {
			// need a copy because it's passed by ref and destroyed in the formatter
			$this->assoc_args_theme = $assoc_args;
			$this->_do_themes();
		}

		if ( ! $this->verbose ) {
			if ( $this->update_list ) {
				exit(1);
			} else {
				exit(0);
			}
		}

	}

	/**
	 * Helper. Call worker for plugin tasks
	 *
	 * @return void
	 */
	private function _do_plugins() {

		$this->_do_thing( 'plugin' );

	}

	/**
	 * Helper. Call worker for theme tasks
	 *
	 * @return void
	 */
	private function _do_themes() {

		$this->_do_thing( 'theme' );

	}

	/**
	 * Worker. Do what's needed for plugins/themes
	 * Prints status if verbose
	 * If silent, only exits if error running update command
	 *
	 * @param string|array $slug The "thing" we're checking
	 *                           If string, it's pluralized with an "s"
	 *                           If array, should be [ single, plural ]
	 * @return void
	 */
	private function _do_thing( $type ) {
		if ( is_array( $type ) ) {
			$singular_type = $type[0];
			$plural_type   = $type[1];
		} else {
			$singular_type = $type;
			$plural_type   = "{$type}s";
		}

		$label = ucwords( $plural_type );

		// deal with our "thing"-specific methods/vars
		$method     = "_check_{$plural_type}";
		$assoc_args = "assoc_args_{$singular_type}";

		$display     = $this->$method();
		$update_list = $this->_extract_updatable_items( $display );

		// if verbose, print some stuff for the user
		if ( $this->verbose ) {

			WP_CLI::log( WP_CLI::colorize( "%G$label%n" ) );

			$formatter = new \WP_CLI\Formatter( $this->$assoc_args, [ 'name', 'installed version', 'status', 'fix' ], $plural_type );
			$formatter->display_items( $display );

			// if plugins need updating, do or tell the user
			$update_list = array_keys( $update_list );
			if ( $update_list ) {
				if ( $this->fix ) {
					WP_CLI::run_command( array_merge( [ $singular_type, 'update' ], $update_list ) );
				} else {
					$update_list = implode( ' ', $update_list );
					WP_CLI::log( "Run `wp $singular_type update $update_list`" );
				}
			} else {
				WP_CLI::log( 'Nothing to update' );
			}

		// if not-verbose, shhhh
		} else {

			if ( $update_list ) {
				if ( $this->fix ) {
					WP_CLI::launch_self( array_merge( [ $singular_type, 'update' ], $update_list ) );
				} else {
					// tell the user that there are vulns that need to be updated
					$this->update_list = array_merge( $this->update_list, $update_list );
					// exit(1);
				}
			} else {
				// nothing to update, no error (but don't exit here)
			}

		}
	}
	/**
	 * Helper. Call worker for checking plugins
	 *
	 * @return array Statuses for all plugins
	 */
	private function _check_plugins() {
		return $this->_check_thing( 'plugin' );
	}

	/**
	 * Helper. Call worker for checking themes
	 *
	 * @return array Statuses for all themes
	 */
	private function _check_themes() {
		return $this->_check_thing( 'theme' );
	}

	/**
	 * Worker. Run through checking the status of a plugin/theme
	 *
	 * @param string|array $slug The "thing" we're checking
	 *                           If string, it's pluralized with an "s"
	 *                           If array, should be [ single, plural ]
	 * @return array Statuses for all themes
	 */
	private function _check_thing( $type ) {
		if ( is_array( $type ) ) {
			$singular_type = $type[0];
			$plural_type   = $type[1];
		} else {
			$singular_type = $type;
			$plural_type   = "{$type}s";
		}

		$list = WP_CLI::launch_self( $singular_type, ['list'], ['format' => 'csv', 'fields' => 'name,version'], true, true );

		$list = $this->parse_list( $list );

		# test list
		if ( $this->test ) {
			switch ( $type )  {
				case 'plugin':
					$list = array(
						[ 'name' => 'wordpress-seo',             'version' => '3.2.5' ],  // no vulns
						// [ 'name' => 'revslider',                 'version' => '1.0.0' ],  // vulns
						// [ 'name' => 'fluid-respnsive-slideshow', 'version' => '2.2.6' ],  // vulns, not fixed
					);
					break;
				case 'theme':
					$list = array(
						[ 'name' => 'twentyten',                 'version' => '1.0.0' ],
						[ 'name' => 'twentyfifteen',             'version' => '1.0.0' ],
						[ 'name' => 'epic',                      'version' => '1.0.0' ],
					);
					break;
			}
		}
		#/

		$data = [];

		foreach ( $list as $thing ) {

			$status = $this->_check_status( $thing['name'], $thing['version'], $singular_type );

			$data = array_merge( $data, $status );

		}

		return $data;

	}

	/**
	 * Pull updatable items from Formatter-ready array
	 *
	 * @param array $data Formatter-ready data
	 * @return array Simple array of plugin/theme slugs needing to be updated
	 */
	private function _extract_updatable_items( $data ) {
		$update_list = wp_list_pluck( wp_list_filter( $data, ['action' => 'update'] ), 'action', 'slug' );
		return $update_list;
	}

	/**
	 * Check wpvulndb.com for reports
	 * Total how many are relevant
	 *
	 * @param string $slug Installed plugin/theme slug
	 * @param string $version Installed plugin/theme version
	 * @param string|array $type The "thing" we're checking, "plugin" or "theme"
	 *                           If string, it's pluralized with an "s"
	 *                           If array, should be [ single, plural ]
	 * @param array $assoc_args
	 * @return array Data array
	 */
	private function _check_status( $slug, $version, $type ) {
		if ( is_array( $type ) ) {
			$singular_type = $type[0];
			$plural_type   = $type[1];
		} else {
			$singular_type = $type;
			$plural_type   = "{$type}s";
		}

		$url = "https://wpvulndb.com/api/v1/{$plural_type}/{$slug}";
		$key = 'vuln_check-' . md5( $url );

		if ( !( $response = get_transient( $key ) ) ) {
			$response = wp_remote_get( $url );
			set_transient( $key, $response, HOUR_IN_SECONDS );
		} else {
			WP_CLI::debug( "Use response cache for $url" );
		}

		$code = wp_remote_retrieve_response_code( $response );
		$body = wp_remote_retrieve_body( $response );

		$assoc_args = "assoc_args_{$singular_type}";

		$table_format = false;
		if ( ! isset( $this->{$assoc_args}['format'] ) || 'table' == $this->{$assoc_args}['format'] ) {
			$table_format = true;
		}

		$report = [];

		if ( 404 == $code ) {
			$report[] = [
				'title' => "No reported vulns for $slug",
				'fix'   => 'n/a'
			];
		} else {

			// let's analyse the report!
			$vulndb = json_decode( $body );

			$vulnerabilities = $vulndb->$singular_type->vulnerabilities;

			foreach ( $vulnerabilities as $k => $vuln ) {

				// vulnerability that hasn't been fixed :(
				if ( ! isset( $vuln->fixed_in ) ) {

					$report[] = [
						'title'  => $vuln->title,
						'fix'    => 'Not fixed',
						'action' => 'watch',
					];

				// vuln version, fix available
				} elseif ( version_compare( $version, $vuln->fixed_in, '<' ) ) {

					$report[] = [
						'title'  => $vuln->title,
						'fix'    => "Fixed in {$vuln->fixed_in}",
						'action' => 'update',
					];

				// if installed plugin version is greater than a fixed version,
				//    unset that vuln entry, we don't need it
				} else {

					// This leaves us with an array of relevant vulns
					// not currently used :/
					unset( $vulnerabilities[ $k ] );

				}

			}

			$total = count( $report );
			if ( $total <= 0 ) {
				$report[] = [
					'title' => "No vulns reported for this version of $slug",
					'fix'   => 'n/a'
				];
			}

		}

		$data = [];

		$last_item = '';
		foreach ( $report as $stat ) {
			if ( ! isset( $stat['action'] ) ) {
				$stat['action'] = '';
			}

			$name = ( $table_format && $slug == $last_item ? '' : $slug );

			if ( $table_format ) {
				switch ( $stat['action'] ) {
					case 'update' :
						$name = WP_CLI::colorize( "%r$name%n" );
						break;
					case 'watch' :
						$name = WP_CLI::colorize( "%y$name%n" );
						break;
					default;
				}
			}

			// these keys must match the column headings in the formatter (extras ok)
			$data[] = [
				'name'   => $name,
				'slug'   => $slug,
				'installed version'   => $version,
				'status' => $stat['title'],
				'fix'    => $stat['fix'],
				'action' => isset( $stat['action'] ) ? $stat['action'] : '',
			];
			$last_item = $slug;
		}

		return $data;

	}

	/**
	 * Parse list string into item array
	 *
	 * @param string $list
	 * @return array
	 */
	private function parse_list( $list ) {

		$list = explode( "\n", $list );
		$newlist = [];

		foreach ( $list as $line ) {
			// skip printed command
			if ( '$ ' === substr( $line, 0, 2 ) ) continue;
			// skip output header
			if ( 'name,version' === $line ) continue;
			// skip output footer
			if ( empty( $line ) ) break;

			$newlist[] = array_combine(
				['name', 'version'],
				explode( ',', $line )
			);

		}

		return $newlist;

	}
}

WP_CLI::add_command( 'vuln', 'Vulnerability_CLI' );