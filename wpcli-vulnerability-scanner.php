<?php
/**
 * Plugin Name:       10up WP-CLI Vulnerability Scanner
 * Plugin URI:        https://github.com/10up/wpcli-vulnerability-scanner
 * Description:       WP-CLI command only. Check WordPress code, installed plugins and themes for vulnerabilities reported by wpvulndb.com.
 * Version:           1.0.0
 * Requires at least: 3.7
 * Requires PHP:      5.4
 * Tested up to:      5.9
 * Author:            10up
 * Author URI:        https://10up.com
 * License:           MIT
 * License URI:       https://spdx.org/licenses/MIT.html
 * Update URI:        https://github.com/10up/wpcli-vulnerability-scanner
 *
 */
if ( ! defined( 'WP_CLI' ) ) {
	return;
}

// API URL constant defined so we can override it if needed.
if ( ! defined( 'VULN_API_URL' ) ) {
	define( 'VULN_API_URL', 'https://wpvulndb.com/api/v3/' );
}

/**
 * WP-CLI Vulnerability Scanner
 */
class Vulnerability_CLI extends WP_CLI_Command {


	/**
	 */
	protected $api_url = VULN_API_URL;

	/**
	 */
	var $porcelain;

	/**
	 */
	var $test;

	/**
	 */
	var $update_list;

	/**
	 */
	var $assoc_args_wordpress;

	/**
	 */
	var $assoc_args_plugin;

	/**
	 */
	var $assoc_args_theme;

	/**
	 * Flag for nagios
	 */
	var $nagios_op;

	/**
	 * Flag for mail
	 */
	var $mail;

	/**
	 * Check plugins and themes for reported vulnerabilities.
	 *
	 * ## OPTIONS
	 *
	 * [--test]
	 * : Load test plugin/theme data
	 *
	 * [--nagios]
	 * : Output for nagios
	 *
	 * [--mail]
	 * : Mail nagios output if any vulnerability found
	 *
	 * [--format=<format>]
	 * : Accepted values: table, csv, json, count, ids, yaml. Default: table
	 *
	 * ## EXAMPLES
	 *
	 *     wp vuln status
	 *     wp vuln status --not-themes
	 *
	 * @subcommand status
	 */
	function status( $args, $assoc_args ) {

		$this->porcelain = false;
		$this->test      = isset( $assoc_args['test'] );

		$this->nagios_op = isset( $assoc_args['nagios'] );
		$this->mail      = isset( $assoc_args['mail'] ) ? $assoc_args['mail'] : '';

		$this->update_list = array();

		// need a copy because it's passed by ref and destroyed in the formatter
		$this->assoc_args_plugin    = $assoc_args;
		$this->assoc_args_theme     = $assoc_args;
		$this->assoc_args_wordpress = $assoc_args;

		global $wp_version;

		if ( $this->nagios_op ) {
			$this->_do_nagios_op( array( 'wordpress', 'plugin', 'theme' ) );
		}

		if ( 'json' == $this->{ $assoc_args }['format'] ) {
			echo '{"core":';
			$this->_do_wordpress();
			echo ',"plugins":';
			$this->_do_plugins();
			echo ',"themes":';
			$this->_do_themes();
			echo '}';
			exit( 0 );
		}

		WP_CLI::log( WP_CLI::colorize( '%GWordPress ' . $wp_version . ' %n' ) );
		$this->_do_wordpress();
		WP_CLI::log( WP_CLI::colorize( '%GPlugins%n' ) );
		$this->_do_plugins();
		WP_CLI::log( WP_CLI::colorize( '%GThemes%n' ) );
		$this->_do_themes();

	}

	/**
	 * Check WordPress core for reported vulnerabilities.
	 *
	 * ## OPTIONS
	 *
	 * [--nagios]
	 * : Output for nagios
	 *
	 * [--mail]
	 * : Mail nagios output if any vulnerability found
	 *
	 * [--format=<format>]
	 * : Accepted values: table, csv, json, count, ids, yaml. Default: table
	 *
	 * ## EXAMPLES
	 *
	 *     wp vuln core-status
	 *
	 * @subcommand core-status
	 */
	function core_status( $args, $assoc_args ) {

		$this->porcelain = isset( $assoc_args['porcelain'] );
		$this->test      = isset( $assoc_args['test'] );

		$this->nagios_op = isset( $assoc_args['nagios'] );
		$this->mail      = isset( $assoc_args['mail'] ) ? $assoc_args['mail'] : '';

		$this->update_list = array();

		// need a copy because it's passed by ref and destroyed in the formatter
		$this->assoc_args_wordpress = $assoc_args;

		if ( $this->nagios_op ) {
			$this->_do_nagios_op( array( 'wordpress' ) );
		}

		$this->_do_wordpress();
	}

	/**
	 * Check plugins for reported vulnerabilities.
	 *
	 * ## OPTIONS
	 *
	 * [--porcelain]
	 * : Print only slugs of plugins with updates
	 *
	 * [--test]
	 * : Load test plugin/theme data
	 *
	 * [--nagios]
	 * : Output for nagios
	 *
	 * [--mail]
	 * : Mail nagios output if any vulnerability found
	 *
	 * [--format=<format>]
	 * : Accepted values: table, csv, json, count, ids, yaml. Default: table
	 *
	 * ## EXAMPLES
	 *
	 *     wp vuln plugin-status
	 *
	 * @subcommand plugin-status
	 */
	function plugin_status( $args, $assoc_args ) {

		$this->porcelain = isset( $assoc_args['porcelain'] );
		$this->test      = isset( $assoc_args['test'] );

		$this->nagios_op = isset( $assoc_args['nagios'] );
		$this->mail      = isset( $assoc_args['mail'] ) ? $assoc_args['mail'] : '';

		$this->update_list = array();
		// need a copy because it's passed by ref and destroyed in the formatter.
		$this->assoc_args_plugin = $assoc_args;

		if ( $this->nagios_op ) {
			$this->_do_nagios_op( array( 'plugin' ) );
		}
		$this->_do_plugins();

	}

	/**
	 * Check themes for reported vulnerabilities.
	 *
	 * ## OPTIONS
	 *
	 * [--porcelain]
	 * : Print only slugs of themes with updates
	 *
	 * [--test]
	 * : Load test theme/theme data
	 *
	 * [--nagios]
	 * : Output for nagios
	 *
	 * [--format=<format>]
	 * : Accepted values: table, csv, json, count, ids, yaml. Default: table
	 *
	 * ## EXAMPLES
	 *
	 *     wp vuln theme-status
	 *
	 * @subcommand theme-status
	 */
	function theme_status( $args, $assoc_args ) {

		$this->porcelain = isset( $assoc_args['porcelain'] );
		$this->test      = isset( $assoc_args['test'] );

		$this->nagios_op = isset( $assoc_args['nagios'] );

		$this->update_list = array();

		// need a copy because it's passed by ref and destroyed in the formatter
		$this->assoc_args_theme = $assoc_args;

		if ( $this->nagios_op ) {
			$this->_do_nagios_op( array( 'theme' ) );
		}

		$this->_do_themes();

	}

	/**
	 * Check any given theme.
	 *
	 * ## OPTIONS
	 *
	 * [<slug>...]
	 * : theme slug to check
	 *
	 * [--version]
	 * : Version if other than latest. Only applies if one slug provided
	 *
	 * [--format=<format>]
	 * : Accepted values: table, csv, json, count, ids, yaml. Default: table
	 *
	 * ## EXAMPLES
	 *
	 *     wp vuln theme-check
	 *
	 * @subcommand theme-check
	 */
	function theme_check( $args, $assoc_args ) {

		if ( count( $args ) > 1 ) {
			$version = 0;
		} else {
			$version = isset( $assoc_args['version'] ) ? $assoc_args['version'] : 0;

		}

		$display = array();
		foreach ( $args as $slug ) {
			$status  = $this->_check_status( $slug, $version, 'theme' );
			$display = array_merge( $display, $status );
		}

		$formatter = new \WP_CLI\Formatter( $assoc_args, array(
			'name',
			'installed version',
			'status',
			'fix'
		), 'themes' );
		$formatter->display_items( $display );

	}

	/**
	 * Check any given plugin.
	 *
	 * ## OPTIONS
	 *
	 * [<slug>...]
	 * : plugin slug to check
	 *
	 * [--version]
	 * : Version if other than latest. Only applies if one slug provided
	 *
	 * [--format=<format>]
	 * : Accepted values: table, csv, json, count, ids, yaml. Default: table
	 *
	 * ## EXAMPLES
	 *
	 *     wp vuln plugin-check
	 *
	 * @subcommand plugin-check
	 */
	function plugin_check( $args, $assoc_args ) {

		if ( count( $args ) > 1 ) {
			$version = 0;
		} else {
			$version = isset( $assoc_args['version'] ) ? $assoc_args['version'] : 0;

		}

		$display = array();
		foreach ( $args as $slug ) {
			$status  = $this->_check_status( $slug, $version, 'plugin' );
			$display = array_merge( $display, $status );
		}

		$formatter = new \WP_CLI\Formatter( $assoc_args, array(
			'name',
			'installed version',
			'status',
			'fix'
		), 'plugins' );
		$formatter->display_items( $display );

	}

	/**
	 * Do WordPress core check
	 *
	 * @return void
	 */
	private function _do_wordpress() {

		$singular_type = 'wordpress';
		$plural_type   = 'wordpresses';

		$assoc_args = "assoc_args_{$singular_type}";

		$display     = $this->_check_wordpress();
		$update_list = $this->_extract_updatable_items( $display );

		$display_format = isset( $this->$assoc_args['format'] ) && ! empty( $this->$assoc_args['format'] ) ? $this->$assoc_args['format'] : 'table';
		$display        = $this->format_data_for_return( $display_format, $display );

		// Pretty print
		if ( ! $this->porcelain ) {
			$formatter = new \WP_CLI\Formatter( $this->$assoc_args, array(
				'name',
				'installed version',
				'status',
				'introduced in',
				'fix',
			), $plural_type );
			// Add second array parameter to indicate the position of the column having a maybe colorized item.
			$formatter->display_items(
				$display,
				array(
					true,
					false,
					false,
					false,
					false,
				)
			);
			// Improve readeability: force new line.
			if ( 'ids' === $display_format ) {
				WP_CLI::log( '' );
			}
		} elseif ( $update_list ) {
			WP_CLI::log( implode( ' ', $update_list ) );
			die;
		}
	}

	/**
	 * Helper. Call worker for plugin tasks
	 *
	 * @return void
	 */
	private function _do_plugins() {
		$this->_do_thing( 'plugin' );
	}

	/**
	 * Helper. Call worker for theme tasks
	 *
	 * @return void
	 */
	private function _do_themes() {
		$this->_do_thing( 'theme' );
	}

	/**
	 * Worker. Do what's needed for plugins/themes
	 * Display table, or if --porcelain, display only updatable slugs
	 *
	 * @param string|array $type The "thing" we're checking
	 *                           If string, it's pluralized with an "s"
	 *                           If array, should be [ single, plural ]
	 *
	 * @return void
	 */
	private function _do_thing( $type ) {
		list( $singular_type, $plural_type ) = $this->_get_slugs( $type );

		$assoc_args = "assoc_args_{$singular_type}";

		$display     = $this->_check_thing( $singular_type );
		$update_list = $this->_extract_updatable_items( $display );

		$display_format = isset( $this->$assoc_args['format'] ) && ! empty( $this->$assoc_args['format'] ) ? $this->$assoc_args['format'] : 'table';
		$display        = $this->format_data_for_return( $display_format, $display );

		// Pretty print.
		if ( ! $this->porcelain ) {

			$formatter = new \WP_CLI\Formatter( $this->$assoc_args, array(
				'name',
				'installed version',
				'status',
				'introduced in',
				'fix',
			), $plural_type );
			// Add second array parameter to indicate the position of the column having a maybe colorized item.
			$formatter->display_items(
				$display,
				array(
					true,
					false,
					false,
					false,
					false,
				)
			);

			// if plugins need updating, do or tell the user.
			if ( $update_list ) {
				// it would be nice to show this, but we'd need to rewrite the unit test
				//              $update_list = implode( ' ', $update_list );
				//              WP_CLI::log( "Run `wp $singular_type update $update_list`" );
			} elseif( ( isset( $this->{$assoc_args}['format'] ) && 'json' != $this->$assoc_args['format'] ) ) {
				WP_CLI::log( 'Nothing to update' );
			}

			// Improve readeability: force new line.
			if ( 'ids' === $display_format ) {
				WP_CLI::log( '' );
			}
		} elseif ( $update_list ) {
			WP_CLI::log( implode( ' ', $update_list ) );
			die;
		}
	}

	/**
	 * Worker. Run through checking the status of a plugin/theme
	 *
	 * @param string|array $type The "thing" we're checking
	 *                           If string, it's pluralized with an "s"
	 *                           If array, should be [ single, plural ]
	 *
	 * @return array Statuses for all themes
	 */
	private function _check_thing( $type ) {
		list( $singular_type ) = $this->_get_slugs( $type );

		$list = WP_CLI::launch_self( $singular_type, array( 'list' ), array(
			'format' => 'csv',
			'fields' => 'name,version',
		), true, true );

		$list = $this->parse_list( $list );

		# test list
		if ( isset( $this->test ) && $this->test ) {
			switch ( $type ) {
				case 'plugin':
					$list = array(
						array( 'name' => 'relevant', 'version' => '1.0.2' ),  // fixed vulns
						// array( 'name' => 'wordpress-seo',             'version' => '3.2.5' ),  // no vulns
						// array( 'name' => 'revslider',                 'version' => '1.0.0' ),  // fixed vulns
						// array( 'name' => 'fluid-respnsive-slideshow', 'version' => '2.2.6' ),  // ongoing vulns
					);
					break;
				case 'theme':
					$list = array(
						array( 'name' => 'digital-store', 'version' => '1.3' ),  // fixed vulns
						// array( 'name' => 'twentyten',                 'version' => '1.0.0' ),  // no vulns
						// array( 'name' => 'twentyfifteen',             'version' => '1.0.0' ),  // fixed vulns
						// array( 'name' => 'epic',                      'version' => '1.0.0' ),  // ongoing vulns
					);
					break;
			}
		}
		#/

		$data = array();

		foreach ( $list as $thing ) {

			$status = $this->_check_status( $thing['name'], $thing['version'], $singular_type );

			$data = array_merge( $data, $status );

		}

		return $data;

	}

	/**
	 * Worker for WordPress vulnerability checks
	 *
	 * @return array
	 */
	private function _check_wordpress() {
		$singular_type = 'wordpress';
		$plural_type   = 'wordpresses';

		global $wp_version;

		$version  = str_replace( '.', '', $wp_version );
		$endpoint = $plural_type . '/' . $version;

		$response = $this->call( $endpoint );


		$code = wp_remote_retrieve_response_code( $response );
		$body = wp_remote_retrieve_body( $response );

		$assoc_args = "assoc_args_{$singular_type}";

		$table_format = false;
		if ( ! isset( $this->{$assoc_args}['format'] ) || 'table' == $this->{$assoc_args}['format'] ) {
			$table_format = true;
		}

		$report = array();

		if ( 404 === $code ) {
			$report[] = array(
				'title' => "Error generating report for WordPress " . $wp_version,
			);
		} else if ( 429 === $code ) {
			$report[] = array(
				'title' => 'ERROR_API_QUOTA_FULL: exceed daily rate limit hit.',
			);
		} else {

			// let's analyse the report!
			$vulndb = json_decode( $body );

			if ( ! isset( $vulndb->$wp_version ) || isset( $vulndb->error ) ) {
				if ( isset( $vulndb->error ) ) {
					$report[] = array(
						'title' => $vulndb->error,
					);
				} else {
					$report[] = array(
						'title' => "NVF Error generating report for WordPress " . $wp_version,
					);
				}
			} else {

				$vulnerabilities = $vulndb->$wp_version->vulnerabilities;

				if ( is_array( $vulnerabilities ) ) {
					foreach ( $vulnerabilities as $k => $vuln ) {

						// API has records for when was introduced ?
						$reported_since = $this->obj_has_non_empty_prop( 'introduced_in', $vuln );
						// Check for fix version.
						$fixed_since = $this->obj_has_non_empty_prop( 'fixed_in', $vuln );

						// vulnerability that hasn't been fixed :(
						if ( ! $fixed_since ) {

							$report[] = array(
								'id'            => $vuln->id,
								'title'         => $vuln->title,
								'fix'           => 'Not fixed',
								'introduced_in' => $reported_since ? $vuln->introduced_in : 'n/a',
								'action'        => 'watch',
							);

							// vuln version, fix available.
						} elseif (
							// If no records for when it was introduced, compare fixed version against current .
							(
								! $reported_since
								&& version_compare( $version, $vuln->fixed_in, '<' )
							)
							||
							(
								// If have records for when it was introduced.
								$reported_since
								// Check if using version with introduced vulnerablity.
								&& version_compare( $version, $vuln->introduced_in, '>=' )
								// Check if using version with vulnerablity fixed.
								&& version_compare( $version, $vuln->fixed_in, '<' )
							)
						) {

							$report[] = array(
								'id'            => $vuln->id,
								'title'         => $vuln->title,
								'fix'           => " Fixed in {$vuln->fixed_in}",
								'introduced_in' => $reported_since ? $vuln->introduced_in : 'n/a',
								'action'        => 'update',
							);

							// if installed plugin version is greater than a fixed version,
							// unset that vuln entry, we don't need it.
						} else {

							// This leaves us with an array of relevant vulns
							// not currently used :/
							unset( $vulnerabilities[ $k ] );
						}
					}
				}

				$total = count( $report );
				if ( $total <= 0 ) {
					$report[] = array(
						'title' => "No vulnerabilities reported for this version of WordPress",
					);
				}
			}
		}

		$data = array();

		foreach ( $report as $index => $stat ) {

			$stat = wp_parse_args(
				$stat,
				array(
					'id'            => '',
					'action'        => '',
					'fix'           => 'n/a',
					'introduced_in' => 'n/a',
				)
			);

			$name = ( $table_format && 0 != $index ? '' : 'WordPress' );

			if ( $table_format ) {
				switch ( $stat['action'] ) {
					case 'update':
						$name = \WP_CLI::colorize( "%r$name%n" );
						break;
					case 'watch':
						$name = \WP_CLI::colorize( "%y$name%n" );
						break;
					default;
				}
			}

			// these keys must match the column headings in the formatter (extras ok).
			$data[] = array(
				'name'              => $name,
				'slug'              => 'wordpress',
				'installed version' => $wp_version,
				'id'                => $stat['id'],
				'status'            => $stat['title'],
				'fix'               => $stat['fix'],
				'introduced in'     => $stat['introduced_in'],
				'action'            => $stat['action'],
			);
		}

		return $data;

	}

	/**
	 * Pull updatable items from Formatter-ready array
	 *
	 * @param array $data Formatter-ready data
	 *
	 * @return array Simple array of plugin/theme slugs needing to be updated
	 */
	private function _extract_updatable_items( $data ) {
		$update_list = wp_list_pluck( wp_list_filter( $data, array( 'action' => 'update' ) ), 'action', 'slug' );
		$update_list = array_keys( $update_list );

		return $update_list;
	}

	/**
	 * Check wpvulndb.com for reports
	 * Total how many are relevant
	 *
	 * @param string       $slug Installed plugin/theme slug
	 * @param string       $version Installed plugin/theme version
	 * @param string|array $type The "thing" we're checking, "plugin" or "theme"
	 *                           If string, it's pluralized with an "s"
	 *                           If array, should be [ single, plural ]
	 *
	 * @return array Data array
	 */
	private function _check_status( $slug, $version, $type ) {
		list( $singular_type, $plural_type ) = $this->_get_slugs( $type );

		$endpoint = $plural_type . '/' . $slug;
		$response = $this->call( $endpoint );

		$code = wp_remote_retrieve_response_code( $response );
		$body = wp_remote_retrieve_body( $response );

		$assoc_args = "assoc_args_{$singular_type}";

		$table_format = false;
		if ( ! isset( $this->{$assoc_args}['format'] ) || 'table' == $this->{$assoc_args}['format'] ) {
			$table_format = true;
		}

		$report = array();

		if ( 404 === $code ) {
			$report[] = array(
				'title' => "Error generating report for $slug",
			);
		} else if ( 429 === $code ) {
			$report[] = array(
				'title' => 'ERROR_API_QUOTA_FULL: exceed daily rate limit hit.',
			);
		} else {

			// let's analyse the report!
			$vulndb = json_decode( $body );

			if ( isset( $vulndb->error ) ) {
				$report[] = array(
					'title' => "Error generating report for $slug",
				);
			}

			$vulnerabilities = array();

			if ( isset( $vulndb->$slug ) && isset( $vulndb->$slug->vulnerabilities ) ) {
				$vulnerabilities = $vulndb->$slug->vulnerabilities;
			}

			if ( is_array( $vulnerabilities ) && ! empty( $vulnerabilities ) ) {
				foreach ( $vulnerabilities as $k => $vuln ) {
					// API has records for when was introduced ?
					$reported_since = $this->obj_has_non_empty_prop( 'introduced_in', $vuln );
					// Check for fix version.
					$fixed_since = $this->obj_has_non_empty_prop( 'fixed_in', $vuln );

					// vulnerability that hasn't been fixed :(
					if ( ! $fixed_since ) {

						$report[] = array(
							'id'            => $vuln->id,
							'title'         => $vuln->title,
							'fix'           => 'Not fixed',
							'introduced_in' => $reported_since ? $vuln->introduced_in : 'n/a',
							'action'        => 'watch',
						);

						// vuln version, fix available.
					} elseif (
						// If no records for when it was introduced, compare fixed version against current .
						(
							! $reported_since
							&& version_compare( $version, $vuln->fixed_in, '<' )
						)
						||
						(
							// If have records for when it was introduced.
							$reported_since
							// Check if using version with introduced vulnerablity.
							&& version_compare( $version, $vuln->introduced_in, '>=' )
							// Check if using version with vulnerablity fixed.
							&& version_compare( $version, $vuln->fixed_in, '<' )
						)
					) {

						$report[] = array(
							'id'            => $vuln->id,
							'title'         => $vuln->title,
							'fix'           => "Fixed in {$vuln->fixed_in}",
							'introduced_in' => $reported_since ? $vuln->introduced_in : 'n/a',
							'action'        => 'update',
						);

						// if installed plugin version is greater than a fixed version,
						// unset that vuln entry, we don't need it.
					} else {

						// This leaves us with an array of relevant vulns
						// not currently used :/
						unset( $vulnerabilities[ $k ] );
					}
				}
			}

			$total = count( $report );
			if ( $total <= 0 ) {
				$report[] = array(
					'title' => "No vulnerabilities reported for this version of $slug",
				);
			}
		}

		$data = array();

		$last_item = '';
		foreach ( $report as $stat ) {

			$stat = wp_parse_args(
				$stat,
				array(
					'id'            => '',
					'action'        => '',
					'fix'           => 'n/a',
					'introduced_in' => 'n/a',
				)
			);
			$name = ( $table_format && $slug == $last_item ? '' : $slug );

			if ( $table_format ) {
				switch ( $stat['action'] ) {
					case 'update':
						$name = WP_CLI::colorize( "%r$name%n" );
						break;
					case 'watch':
						$name = WP_CLI::colorize( "%y$name%n" );
						break;
					default;
				}
			}

			// these keys must match the column headings in the formatter (extras ok).
			$data[]    = array(
				'name'              => $name,
				'slug'              => $slug,
				'installed version' => $version,
				'id'                => $stat['id'],
				'status'            => $stat['title'],
				'fix'               => $stat['fix'],
				'introduced in'     => $stat['introduced_in'],
				'action'            => $stat['action'],
			);
			$last_item = $slug;
		}

		return $data;

	}

	/**
	 * Get singular and plural slugs for given string or array
	 *
	 * @param string|array $singular_or_array If string, it's pluralized with an "s"
	 *                           If array, should be [ single, plural ]
	 *
	 * @return array
	 */
	private function _get_slugs( $singular_or_array ) {
		if ( is_array( $singular_or_array ) ) {
			$singular_type = $singular_or_array[0];
			$plural_type   = $singular_or_array[1];
		} else {
			$singular_type = $singular_or_array;
			$plural_type   = "{$singular_or_array}s";
		}

		return array( $singular_type, $plural_type );
	}

	/**
	 * Parse list string into item array
	 *
	 * @param string $list
	 *
	 * @return array
	 */
	private function parse_list( $list ) {

		$list    = explode( "\n", $list );
		$newlist = array();

		foreach ( $list as $line ) {
			// skip printed command
			if ( '$ ' === substr( $line, 0, 2 ) ) {
				continue;
			}
			// skip output header
			if ( 'name,version' === $line ) {
				continue;
			}
			// skip output footer
			if ( empty( $line ) ) {
				break;
			}

			$newlist[] = array_combine(
				array( 'name', 'version' ),
				explode( ',', $line )
			);

		}

		return $newlist;

	}

	/**
	 * Do nagios output
	 *
	 * @param $things
	 */
	private function _do_nagios_op( $things ) {
		if ( ! empty( $things ) && is_array( $things ) ) {

			$wp_list = $pl_list = $th_list = 0;

			if ( in_array( 'wordpress', $things ) ) {
				$wp_vulns = $this->_check_wordpress();
				if ( ! empty( $wp_vulns ) && is_array( $wp_vulns ) ) {
					foreach ( $wp_vulns as $wp_vuln ) {
						if ( isset( $wp_vuln['fix'] ) && 'n/a' != $wp_vuln['fix'] ) {
							$wp_list ++;
						}
					}
				}
			}
			if ( in_array( 'plugin', $things ) ) {
				$plugins = $this->_check_thing( 'plugin' );
				if ( ! empty( $plugins ) && is_array( $plugins ) ) {
					foreach ( $plugins as $plugin ) {
						if ( isset( $plugin['fix'] ) && 'n/a' != $plugin['fix'] ) {
							$pl_list ++;
						}
					}
				}
			}
			if ( in_array( 'theme', $things ) ) {
				$themes = $this->_check_thing( 'theme' );
				if ( ! empty( $themes ) && is_array( $themes ) ) {
					foreach ( $themes as $theme ) {
						if ( isset( $theme['fix'] ) && 'n/a' != $theme['fix'] ) {
							$th_list ++;
						}
					}
				}
			}

			if ( empty( $wp_list ) && empty( $pl_list ) && empty( $th_list ) ) {
				WP_CLI::line( 'OK - no vulnerabilities found' );
				exit( 0 );
			} else {
				$message = sprintf(
					'CRITICAL - %d core, %d plugin and %d theme vulnerabilities found',
					$wp_list,
					$pl_list,
					$th_list
				);
				WP_CLI::line( $message );

				//Notify via mail
				if ( ! empty( $this->mail ) ) {

					$site_url = site_url();
					$headers  = array();

					/*
					 * In CLI if $_SERVER['SERVER_NAME'] isn't set than it fails to send mail.
					 * Reason being, this property is used to create "From" mail header.
					 * If it's empty, we need to pass that in header.
					 */
					if ( empty( $_SERVER['SERVER_NAME'] ) ) {
						$sitename = $site_url;
						if ( substr( $sitename, 0, 8 ) == 'https://' ) {
							$sitename = substr( $sitename, 8 );
						}
						if ( substr( $sitename, 0, 7 ) == 'http://' ) {
							$sitename = substr( $sitename, 7 );
						}
						if ( substr( $sitename, 0, 4 ) == 'www.' ) {
							$sitename = substr( $sitename, 4 );
						}

						$from_email = 'wordpress@' . $sitename;

						$headers[] = "From:{$from_email}";
					}

					$subject = 'Vulnerabilities found in ' . $site_url;
					if ( ! wp_mail( $this->mail, $subject, $message, $headers ) ) {
						WP_CLI::line( 'Not able to send mail.' );
					}
				}

				exit( 2 );
			}
		}
	}

	/**
	 * Call the VulnDB API.
	 *
	 * @param string $endpoint The endpoint.
	 *
	 * @return array|mixed|WP_Error
	 */
	protected function call( $endpoint ) {

		if ( ! defined( 'VULN_API_TOKEN' ) ) {
			WP_CLI::error( 'VULN_API_TOKEN is not set.' );
			die();
		}

		$url = $this->api_url . $endpoint;

		$key = 'vuln_check-' . md5( $url );

		$args = [
			'headers' => [
				'Authorization' => 'Token token=' . VULN_API_TOKEN,
			],
			'method'  => 'GET',
		];

		if ( ! ( $response = get_transient( $key ) ) ) {
			$response = wp_remote_request( $url, $args );
			set_transient( $key, $response, HOUR_IN_SECONDS );
		} else {
			WP_CLI::debug( "Use response cache for $url" );
		}

		return $response;
	}

	/**
	 * Helper function to check for a given property in an object
	 *
	 * @param string $field  Property name.
	 * @param object $object Object having vulnerability details.
	 * @return bool          Flag indicating the API
	 */
	protected function obj_has_non_empty_prop( $field, $object ) {
		return isset( $object->{$field} ) && ! ( empty( $object->{$field} ) );
	}

	/**
	 * Format data before output based on --format parameter passed to command.
	 *
	 * @param string $output_format  One of table, csv, json, count, ids, yaml.
	 * @param array  $data           Array having report details.
	 * @return array $applied_format Array for correct output.
	 */
	protected function format_data_for_return( $output_format, $data ) {

		switch ( $output_format ) {
			case 'ids':
				$applied_format = array_filter( wp_list_pluck( $data, 'id' ) );
				break;
			default:
				$applied_format = $data;
		}

		return $applied_format;
	}
}

WP_CLI::add_command( 'vuln', 'Vulnerability_CLI' );
