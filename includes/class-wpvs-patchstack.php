<?php
/**
 * WPVS_Patchstack Class.
 *
 * @package WP-CLI Vulnerability Scanner
 */

if ( ! defined( 'ABSPATH' ) ) {
	exit; // Exit if accessed directly.
}

// API URL constant defined so we can override it if needed.
if ( ! defined( 'PATCHSTACK_API_URL' ) ) {
	define( 'PATCHSTACK_API_URL', 'https://patchstack.com/database/api/v2/' );
}

/**
 * Class for Patchstack Service
 */
class WPVS_Patchstack extends WPVS_Service {

	/**
	 * Patchstack API URL.
	 *
	 * @var string
	 */
	private $api_url = PATCHSTACK_API_URL;

	/**
	 * Worker for WordPress vulnerability checks
	 *
	 * @return array
	 */
	public function check_wordpress() {
		global $wp_version;
		$slug = 'wordpress';

		// Get data from API.
		$endpoint = "product/$slug/$slug/$wp_version";
		$response = $this->call( $endpoint );

		$args = array(
			'slug'    => $slug,
			'version' => $wp_version,
		);

		// Prepare and return report data.
		return $this->prepare_report_data( $response, $args );
	}

	/**
	 * Check patchstack.com for reports.
	 *
	 * @param string       $slug    Installed plugin/theme slug.
	 * @param string       $version Installed plugin/theme version.
	 * @param string|array $type    The "thing" we're checking, "plugin" or "theme".
	 *                              If string, it's pluralized with an "s".
	 *                              If array, should be [ single, plural ].
	 *
	 * @return array Data array
	 */
	public function check_status( $slug, $version, $type ) {
		list( $singular_type ) = $this->get_slugs( $type );
		// Get data from API.
		$endpoint = "product/$singular_type/$slug/$version";
		$response = $this->call( $endpoint );

		$args = array(
			'slug'    => $slug,
			'version' => $version,
		);

		// Prepare and return report data.
		return $this->prepare_report_data( $response, $args );
	}

	/**
	 * Worker. Run through checking the status of a plugin/theme
	 *
	 * @param string|array $type The "thing" we're checking.
	 *                           If string, it's pluralized with an "s"
	 *                           If array, should be [ single, plural ].
	 *
	 * @return array Statuses for all themes
	 */
	public function check_thing( $type ) {
		list( $singular_type ) = $this->get_slugs( $type );

		$list = WP_CLI::launch_self(
			$singular_type,
			array( 'list' ),
			array(
				'format' => 'csv',
				'fields' => 'name,version',
			),
			true,
			true,
		);

		$list = $this->parse_list( $list );

		// test list.
		if ( isset( $this->assoc_args['test'] ) && $this->assoc_args['test'] ) {
			$list = $this->get_test_list( $type );
		}

		$data = array();

		foreach ( $list as $thing ) {

			$status = $this->check_status( $thing['name'], $thing['version'], $singular_type );

			$data = array_merge( $data, $status );

		}

		return $data;
	}

	/**
	 * Prepare data for output
	 *
	 * @param array|mixed|WP_Error $response API response object.
	 * @param array                $args     Arguments related current scan.
	 */
	private function prepare_report_data( $response, $args ) {
		$slug         = $args['slug'];
		$version      = $args['version'];
		$is_wp        = false;
		$display_slug = $slug;
		if ( 'wordpress' === $slug ) {
			$is_wp        = true;
			$display_slug = "WordPress $version";
		}

		$code = wp_remote_retrieve_response_code( $response );
		$body = wp_remote_retrieve_body( $response );

		$table_format = false;
		if ( ! isset( $this->assoc_args['format'] ) || 'table' === $this->assoc_args['format'] ) {
			$table_format = true;
		}

		$report = array();

		if ( 404 === $code ) {
			$report[] = array(
				'title' => "Error generating report for $display_slug",
			);
		} elseif ( 429 === $code ) {
			$report[] = array(
				'title' => 'ERROR_API_QUOTA_FULL: exceed daily rate limit hit.',
			);
		} else {

			// let's analyse the report!
			$vulndb = json_decode( $body );

			if ( ! isset( $vulndb->vulnerabilities ) ) {
				$report[] = array(
					'title' => "Error generating report for $display_slug",
				);
			} else {
				$vulnerabilities = $vulndb->vulnerabilities;

				if ( is_array( $vulnerabilities ) && ! empty( $vulnerabilities ) ) {
					foreach ( $vulnerabilities as $k => $vuln ) {

						// API has records for affected_in ?
						$affected_in = $this->obj_has_non_empty_prop( 'affected_in', $vuln );
						// Check for fix version.
						$fixed_since = $this->obj_has_non_empty_prop( 'fixed_in', $vuln );

						// vulnerability that hasn't been fixed :(.
						if ( ! $fixed_since ) {

							$report[] = array(
								'id'          => $vuln->id,
								'title'       => $vuln->title,
								'fix'         => 'Not fixed',
								'affected_in' => $affected_in ? $vuln->affected_in : 'n/a',
								'action'      => 'watch',
							);

							// vuln version, fix available.
						} elseif ( version_compare( $version, $vuln->fixed_in, '<' ) ) {

							$report[] = array(
								'id'          => $vuln->id,
								'title'       => $vuln->title,
								'fix'         => " Fixed in {$vuln->fixed_in}",
								'affected_in' => $affected_in ? $vuln->affected_in : 'n/a',
								'action'      => 'update',
							);

							// if installed plugin version is greater than a fixed version,
							// unset that vuln entry, we don't need it.
						} else {

							// This leaves us with an array of relevant vulns
							// not currently used :/.
							unset( $vulnerabilities[ $k ] );
						}
					}
				}

				$total = count( $report );
				if ( $total <= 0 ) {
					$report[] = array(
						'title' => 'No vulnerabilities reported for this version of ' . ( $is_wp ? 'WordPress' : $slug ),
					);
				}
			}
		}

		$data = array();
		$last_item = '';
		foreach ( $report as $index => $stat ) {

			$stat = wp_parse_args(
				$stat,
				array(
					'id'          => '',
					'action'      => '',
					'fix'         => 'n/a',
					'affected_in' => 'n/a',
				)
			);

			if ( $is_wp ) {
				$name = ( $table_format && 0 !== $index ? '' : 'WordPress' );
			} else {
				$name = ( $table_format && $slug === $last_item ? '' : $slug );
			}

			if ( $table_format ) {
				switch ( $stat['action'] ) {
					case 'update':
						$name = \WP_CLI::colorize( "%r$name%n" );
						break;
					case 'watch':
						$name = \WP_CLI::colorize( "%y$name%n" );
						break;
					default:
						break;
				}
			}

			// these keys must match the column headings in the formatter (extras ok).
			$data[]    = array(
				'name'              => $name,
				'slug'              => $slug,
				'installed version' => $version,
				'id'                => $stat['id'],
				'status'            => $stat['title'],
				'fix'               => $stat['fix'],
				'introduced in'     => $stat['affected_in'],
				'action'            => $stat['action'],
			);

			$last_item = $slug;
		}

		return $data;
	}

	/**
	 * Call the Patchstack API.
	 *
	 * @param string $endpoint The endpoint.
	 *
	 * @return array|mixed|WP_Error
	 */
	protected function call( $endpoint ) {

		if ( ! defined( 'PATCHSTACK_API_TOKEN' ) ) {
			WP_CLI::error( 'PATCHSTACK_API_TOKEN is not set.' );
			die();
		}

		$url = $this->api_url . $endpoint;

		$key = 'patchstack_check-' . md5( $url );

		$args = array(
			'headers' => array(
				'PSKey' => PATCHSTACK_API_TOKEN,
			),
			'method'  => 'GET',
		);

		$response = get_transient( $key );
		if ( ! $response ) {
			$response = wp_remote_request( $url, $args );
			set_transient( $key, $response, HOUR_IN_SECONDS );
		} else {
			WP_CLI::debug( "Use response cache for $url" );
		}

		return $response;
	}
}
